This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
docs/
  GOOGLE_DOCS_MODE.md
appsscript.json
docs_mode.gs
docs_utils.gs
DriveUtils.gs
Examples.gs
gmail-to-docs.patch
GmailUtils.gs
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(git apply:*)",
      "Bash(sed:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="docs/GOOGLE_DOCS_MODE.md">
# Google Docs Output Mode (gmail-to-docs)

This fork adds a Google Docs output path that **prepends** new emails (newest-first) into a **single consolidated Google Doc**.

## Quick Start

1. In Gmail, create a label (e.g., `CONSOLIDATE_TO_DOC`) and apply it to the messages you want consolidated.
2. Open the Apps Script project and ensure the manifest uses V8 runtime:
   - `appsscript.json` includes `"runtimeVersion": "V8"`.
3. Add the files `docs_mode.gs` and `docs_utils.gs` to your project.
4. In `docs_mode.gs`, set:
   - `CONSOLIDATE_LABEL` to your label (e.g., `CONSOLIDATE_TO_DOC`)
   - `OUTPUT_MODE` to `'doc_plain'` (recommended first) or `'doc_html'` (requires Drive Advanced Service).
5. Run `gtd_init()` once (optional) and then `processMessagesToDoc()` to authorize and process initial messages.
6. Set a time-driven trigger to run `processMessagesToDoc()` on a schedule (e.g., every 10 minutes).

State is stored in Script Properties:
- `gtd_last_iso` — ISO datetime of the last processed message.
- `gtd_consolidated_doc_id` — doc id of the consolidated Google Doc.

## Modes

- `doc_plain`: converts messages to plain text with simple metadata; very robust.
- `doc_html`: attempts HTML → Google Doc conversion via Drive API. Turn on **Advanced Drive Service** in the Apps Script editor (Services → Drive API). Better formatting for some emails, but HTML/CSS fidelity varies, and inline `cid:` images may need custom handling.

## Notes / Next Steps

- For very long Docs (size limits), create monthly archives and rotate `gtd_consolidated_doc_id`.
- Inline images and attachments are not fully handled yet in this first patch. Future work:
  - Embed inline images by fetching attachments that match `Content-ID` and inserting them as images in the Doc.
  - Save non-image attachments to a Drive folder and insert links in the consolidated Doc.
  - Add a guard to skip re-processing already-added messages by tracking message IDs.

## Troubleshooting

- If you see "Service not found: Drive", enable **Advanced Drive Service** (Services → Add a service → Drive API).
- If nothing is added to the doc, confirm your label name matches `CONSOLIDATE_LABEL` and there are labeled messages **newer than** `gtd_last_iso`. You can reset by setting `gtd_last_iso` to `1970-01-01T00:00:00Z` in Script Properties.
- Logs are in **Executions** in the Apps Script editor (or `Logger.log` output).
</file>

<file path="appsscript.json">
{
  "timeZone": "Etc/UTC",
  "dependencies": {},
  "exceptionLogging": "STACKDRIVER",
  "runtimeVersion": "V8"
}
</file>

<file path="docs_mode.gs">
/**
 * docs_mode.gs
 * Orchestrator: incremental processing of Gmail messages and prepending them into
 * a single consolidated Google Doc (newest-first).
 *
 * Behavior:
 *  - Uses a Gmail label (CONSOLIDATE_LABEL) to find candidate threads/messages.
 *  - Keeps state in Script Properties:
 *      PROP_LAST_ISO -> ISO string of last-processed message date
 *      PROP_CONSOLIDATED_DOC -> docId of the consolidated doc
 *  - Newest messages are prepended (appear at top).
 *  - Two output modes supported:
 *      OUTPUT_MODE = 'doc_plain'  -> reliable plain-text conversion
 *      OUTPUT_MODE = 'doc_html'   -> attempt HTML -> Google Doc conversion (requires Drive Advanced Service)
 *
 * NOTE:
 *  - This is intentionally conservative as a first step.
 *  - Attachments and inline images are handled in later iterations.
 */

/* =========================
   Configuration
   ========================= */
const CONSOLIDATE_LABEL       = 'CONSOLIDATE_TO_DOC'; // <-- change to your Gmail label
const PROP_LAST_ISO           = 'gtd_last_iso';
const PROP_CONSOLIDATED_DOC   = 'gtd_consolidated_doc_id';
const MAX_MESSAGES_PER_RUN    = 200;

/* Choose 'doc_plain' for reliability. Use 'doc_html' for HTML->Doc (requires Advanced Drive Service). */
const OUTPUT_MODE             = 'doc_plain'; // or 'doc_html'

/**
 * One-time initialization (optional).
 * - Creates the consolidated Doc if missing.
 * - Seeds last-processed timestamp if not present.
 */
function gtd_init() {
  const props = PropertiesService.getScriptProperties();
  if (!props.getProperty(PROP_LAST_ISO)) {
    props.setProperty(PROP_LAST_ISO, '1970-01-01T00:00:00Z');
  }
  if (!props.getProperty(PROP_CONSOLIDATED_DOC)) {
    const doc = DocumentApp.create('gtd_consolidated_doc');
    props.setProperty(PROP_CONSOLIDATED_DOC, doc.getId());
    Logger.log('Created consolidated doc: %s', doc.getId());
  }
  Logger.log('Initialized. lastISO=%s docId=%s',
             props.getProperty(PROP_LAST_ISO),
             props.getProperty(PROP_CONSOLIDATED_DOC));
}

/**
 * Entry point - schedule this on a time trigger (e.g., every 10 minutes).
 */
function processMessagesToDoc() {
  const props = PropertiesService.getScriptProperties();
  const lastISO = props.getProperty(PROP_LAST_ISO) || '1970-01-01T00:00:00Z';
  let consolidatedDocId = props.getProperty(PROP_CONSOLIDATED_DOC);

  Logger.log('processMessagesToDoc starting. lastISO=%s consolidatedDocId=%s', lastISO, consolidatedDocId);

  // Ensure consolidated doc exists
  if (!consolidatedDocId) {
    const doc = DocumentApp.create('gtd_consolidated_doc');
    consolidatedDocId = doc.getId();
    props.setProperty(PROP_CONSOLIDATED_DOC, consolidatedDocId);
    Logger.log('Created new consolidated doc: %s', consolidatedDocId);
  }

  const lastDate = new Date(lastISO);

  // Find threads with the label
  const query = `label:${CONSOLIDATE_LABEL}`;
  const threads = GmailApp.search(query, 0, MAX_MESSAGES_PER_RUN);

  // Collect messages newer than lastDate
  let newMessages = [];
  for (let i = 0; i < threads.length; i++) {
    const t = threads[i];
    const msgs = t.getMessages();
    for (let j = 0; j < msgs.length; j++) {
      const m = msgs[j];
      const d = m.getDate();
      if (d > lastDate) {
        newMessages.push({date: d, message: m});
      }
    }
  }

  if (newMessages.length === 0) {
    Logger.log('No new messages to process.');
    return;
  }

  // Sort newest -> oldest
  newMessages.sort((a,b) => b.date - a.date);
  Logger.log('Found %s new messages.', newMessages.length);

  let newestSeen = lastDate;

  // Process each new message (newest-first)
  newMessages.forEach(item => {
    const msg = item.message;
    try {
      if (OUTPUT_MODE === 'doc_plain') {
        prependMessageToDocPlain(msg, consolidatedDocId);
      } else if (OUTPUT_MODE === 'doc_html') {
        prependMessageHtmlToDoc(msg, consolidatedDocId);
      } else {
        throw new Error('Unknown OUTPUT_MODE: ' + OUTPUT_MODE);
      }
      if (item.date > newestSeen) newestSeen = item.date;
      Logger.log('Processed message: %s (date=%s)', msg.getSubject(), msg.getDate());
    } catch (e) {
      Logger.log('Error processing message (subject=%s): %s', msg.getSubject(), e.toString());
    }
  });

  // Update state
  props.setProperty(PROP_LAST_ISO, newestSeen.toISOString());
  Logger.log('State updated. new lastISO=%s', newestSeen.toISOString());
}
</file>

<file path="docs_utils.gs">
/**
 * docs_utils.gs
 * Helpers for Google-Doc output mode.
 *
 * Contains:
 *  - prependMessageToDocPlain(msg, consolidatedDocId)
 *  - convertHtmlToDoc(htmlString, title)  (requires Advanced Drive service 'Drive')
 *  - prependMessageHtmlToDoc(msg, consolidatedDocId)
 *  - escapeHtml(s)
 *  - copyElementToBody(child, destBody)   (basic element copier)
 */

/**
 * Prepend a message into consolidated doc using plain text (very reliable).
 * Newest messages are inserted at the top.
 */
function prependMessageToDocPlain(msg, consolidatedDocId) {
  const mainDoc  = DocumentApp.openById(consolidatedDocId);
  const mainBody = mainDoc.getBody();

  // Build temporary doc for the message content
  const tmpDoc  = DocumentApp.create('gtd_tmp_msg_' + new Date().getTime());
  const tmpBody = tmpDoc.getBody();

  tmpBody.appendParagraph('--- EMAIL START ---').setHeading(DocumentApp.ParagraphHeading.HEADING6);
  tmpBody.appendParagraph('Subject: ' + (msg.getSubject() || '(no subject)'));
  tmpBody.appendParagraph('From: ' + (msg.getFrom() || ''));
  tmpBody.appendParagraph('To: ' + (msg.getTo() || ''));
  tmpBody.appendParagraph('Date: ' + msg.getDate().toString());
  tmpBody.appendParagraph('');

  const plain = (msg.getPlainBody && msg.getPlainBody()) ? msg.getPlainBody()
               : (msg.getBody && msg.getBody()) ? msg.getBody()
               : '(no body)';
  plain.split(/\r?\n/).forEach(line => {
    tmpBody.appendParagraph(line);
  });

  tmpBody.appendParagraph('--- EMAIL END ---');
  tmpBody.appendPageBreak();

  // Insert tmpDoc children into mainDoc at the top (insert in reverse so order is preserved)
  const n = tmpBody.getNumChildren();
  for (let i = n - 1; i >= 0; i--) {
    const child = tmpBody.getChild(i).copy();
    try {
      if (child.getType && child.getType() === DocumentApp.ElementType.PARAGRAPH) {
        mainBody.insertParagraph(0, child.asParagraph().getText());
      } else if (child.getType && child.getType() === DocumentApp.ElementType.LIST_ITEM) {
        mainBody.insertListItem(0, child.asListItem().getText());
      } else if (child.getType && child.getType() === DocumentApp.ElementType.PAGE_BREAK) {
        mainBody.insertPageBreak(0);
      } else {
        // fallback - plain text
        mainBody.insertParagraph(0, child.getText ? child.getText() : '[unsupported element]');
      }
    } catch (err) {
      mainBody.insertParagraph(0, '[insert failed: ' + err.toString() + ']');
    }
  }

  // Remove temporary doc to avoid clutter
  DriveApp.getFileById(tmpDoc.getId()).setTrashed(true);
}

/**
 * Convert HTML string into a Google Doc using Drive API convert.
 * Requires Advanced Drive Service enabled in the Apps Script editor (Services -> Drive API).
 * Returns the new docId.
 */
function convertHtmlToDoc(htmlString, title) {
  const blob = Utilities.newBlob(htmlString, 'text/html', title + '.html');
  const resource = {
    title: title,
    mimeType: 'text/html'
  };
  // Drive.Files.insert converts the uploaded HTML into a Google Doc when convert=true
  const file = Drive.Files.insert(resource, blob, {convert: true});
  return file.id;
}

/**
 * Prepend HTML message into consolidated doc.
 * This converts message HTML->Doc via Drive.Files.insert convert=true,
 * then copies the doc content into the consolidated doc.
 *
 * NOTE:
 *  - This is a pragmatic approach; it won't automatically resolve inline 'cid:' images.
 *  - For better fidelity, add image fetching & data-URI replacement before conversion.
 */
function prependMessageHtmlToDoc(msg, consolidatedDocId) {
  const htmlHeader = `
    <html><head><meta charset="utf-8"></head><body>
    <div><strong>Subject:</strong> ${escapeHtml(msg.getSubject() || '')}</div>
    <div><strong>From:</strong> ${escapeHtml(msg.getFrom() || '')}</div>
    <div><strong>To:</strong> ${escapeHtml(msg.getTo() || '')}</div>
    <div><strong>Date:</strong> ${escapeHtml(msg.getDate().toString())}</div>
    <hr/>`;

  // Prefer the HTML body when present
  const bodyHtml = (msg.getBody && msg.getBody()) ? msg.getBody()
                  : escapeHtml((msg.getPlainBody && msg.getPlainBody()) ? msg.getPlainBody() : '(no body)');

  const fullHtml = htmlHeader + bodyHtml + '</body></html>';

  const tmpDocId = convertHtmlToDoc(fullHtml, 'gtd_tmp_html_' + new Date().getTime());

  // Copy children from tmpDoc to consolidated doc at top
  const tmpDoc  = DocumentApp.openById(tmpDocId);
  const tmpBody = tmpDoc.getBody();
  const mainDoc = DocumentApp.openById(consolidatedDocId);
  const mainBody= mainDoc.getBody();

  for (let i = tmpBody.getNumChildren() - 1; i >= 0; i--) {
    const child = tmpBody.getChild(i).copy();
    try {
      if (child.getType && child.getType() === DocumentApp.ElementType.PARAGRAPH) {
        mainBody.insertParagraph(0, child.asParagraph().getText());
      } else if (child.getType && child.getType() === DocumentApp.ElementType.LIST_ITEM) {
        mainBody.insertListItem(0, child.asListItem().getText());
      } else if (child.getType && child.getType() === DocumentApp.ElementType.TABLE) {
        // basic table flattening
        const table = child.asTable();
        for (let r = table.getNumRows() - 1; r >= 0; r--) {
          const row = table.getRow(r);
          let rowText = [];
          for (let c = 0; c < row.getNumCells(); c++) {
            rowText.push(row.getCell(c).getText());
          }
          mainBody.insertParagraph(0, rowText.join('\t'));
        }
      } else if (child.getType && child.getType() === DocumentApp.ElementType.PAGE_BREAK) {
        mainBody.insertPageBreak(0);
      } else if (child.getType && child.getType() === DocumentApp.ElementType.INLINE_IMAGE) {
        const blob = child.asInlineImage().getBlob();
        mainBody.insertImage(0, blob);
      } else {
        mainBody.insertParagraph(0, child.getText ? child.getText() : '[unsupported element]');
      }
    } catch (e) {
      mainBody.insertParagraph(0, '[insert failed: ' + e.toString() + ']');
    }
  }

  // Trash tmp doc
  DriveApp.getFileById(tmpDocId).setTrashed(true);
}

/* Minimal HTML escape to avoid injecting tags into metadata fields */
function escapeHtml(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

/**
 * copyElementToBody(child, destBody)
 * A small element copier to support Paragraphs, ListItems, Tables, InlineImage, PageBreak.
 * Not exhaustive but useful later when preserving element types becomes important.
 */
function copyElementToBody(child, destBody) {
  const type = child.getType();
  switch (type) {
    case DocumentApp.ElementType.PARAGRAPH:
      destBody.appendParagraph(child.asParagraph().getText());
      break;
    case DocumentApp.ElementType.LIST_ITEM:
      destBody.appendListItem(child.asListItem().getText());
      break;
    case DocumentApp.ElementType.TABLE:
      const table = child.asTable();
      for (let r = 0; r < table.getNumRows(); r++) {
        const cells = table.getRow(r).getNumCells();
        let rowText = [];
        for (let c = 0; c < cells; c++) {
          rowText.push(table.getRow(r).getCell(c).getText());
        }
        destBody.appendParagraph(rowText.join('\t'));
      }
      break;
    case DocumentApp.ElementType.INLINE_IMAGE:
      try {
        const blob = child.asInlineImage().getBlob();
        destBody.appendImage(blob);
      } catch (e) {
        destBody.appendParagraph('[image error]');
      }
      break;
    case DocumentApp.ElementType.PAGE_BREAK:
      destBody.appendPageBreak();
      break;
    default:
      try {
        destBody.appendParagraph(child.getText ? child.getText() : child.asText().getText());
      } catch (e) {
        destBody.appendParagraph('[unsupported element]');
      }
  }
}
</file>

<file path="gmail-to-docs.patch">
diff --git a/appsscript.json b/appsscript.json
new file mode 100644
index 0000000..b1c2d3e
--- /dev/null
+++ b/appsscript.json
@@ -0,0 +1,8 @@
+{
+  "timeZone": "Etc/UTC",
+  "dependencies": {},
+  "exceptionLogging": "STACKDRIVER",
+  "runtimeVersion": "V8"
+}
+
+
diff --git a/docs_mode.gs b/docs_mode.gs
new file mode 100644
index 0000000..0f4e2aa
--- /dev/null
+++ b/docs_mode.gs
@@ -0,0 +1,153 @@
+/**
+ * docs_mode.gs
+ * Orchestrator: incremental processing of Gmail messages and prepending them into
+ * a single consolidated Google Doc (newest-first).
+ *
+ * Behavior:
+ *  - Uses a Gmail label (CONSOLIDATE_LABEL) to find candidate threads/messages.
+ *  - Keeps state in Script Properties:
+ *      PROP_LAST_ISO -> ISO string of last-processed message date
+ *      PROP_CONSOLIDATED_DOC -> docId of the consolidated doc
+ *  - Newest messages are prepended (appear at top).
+ *  - Two output modes supported:
+ *      OUTPUT_MODE = 'doc_plain'  -> reliable plain-text conversion
+ *      OUTPUT_MODE = 'doc_html'   -> attempt HTML -> Google Doc conversion (requires Drive Advanced Service)
+ *
+ * NOTE:
+ *  - This is intentionally conservative as a first step.
+ *  - Attachments and inline images are handled in later iterations.
+ */
+
+/* =========================
+   Configuration
+   ========================= */
+const CONSOLIDATE_LABEL       = 'CONSOLIDATE_TO_DOC'; // <-- change to your Gmail label
+const PROP_LAST_ISO           = 'gtd_last_iso';
+const PROP_CONSOLIDATED_DOC   = 'gtd_consolidated_doc_id';
+const MAX_MESSAGES_PER_RUN    = 200;
+
+/* Choose 'doc_plain' for reliability. Use 'doc_html' for HTML->Doc (requires Advanced Drive Service). */
+const OUTPUT_MODE             = 'doc_plain'; // or 'doc_html'
+
+/**
+ * One-time initialization (optional).
+ * - Creates the consolidated Doc if missing.
+ * - Seeds last-processed timestamp if not present.
+ */
+function gtd_init() {
+  const props = PropertiesService.getScriptProperties();
+  if (!props.getProperty(PROP_LAST_ISO)) {
+    props.setProperty(PROP_LAST_ISO, '1970-01-01T00:00:00Z');
+  }
+  if (!props.getProperty(PROP_CONSOLIDATED_DOC)) {
+    const doc = DocumentApp.create('gtd_consolidated_doc');
+    props.setProperty(PROP_CONSOLIDATED_DOC, doc.getId());
+    Logger.log('Created consolidated doc: %s', doc.getId());
+  }
+  Logger.log('Initialized. lastISO=%s docId=%s',
+             props.getProperty(PROP_LAST_ISO),
+             props.getProperty(PROP_CONSOLIDATED_DOC));
+}
+
+/**
+ * Entry point - schedule this on a time trigger (e.g., every 10 minutes).
+ */
+function processMessagesToDoc() {
+  const props = PropertiesService.getScriptProperties();
+  const lastISO = props.getProperty(PROP_LAST_ISO) || '1970-01-01T00:00:00Z';
+  let consolidatedDocId = props.getProperty(PROP_CONSOLIDATED_DOC);
+
+  Logger.log('processMessagesToDoc starting. lastISO=%s consolidatedDocId=%s', lastISO, consolidatedDocId);
+
+  // Ensure consolidated doc exists
+  if (!consolidatedDocId) {
+    const doc = DocumentApp.create('gtd_consolidated_doc');
+    consolidatedDocId = doc.getId();
+    props.setProperty(PROP_CONSOLIDATED_DOC, consolidatedDocId);
+    Logger.log('Created new consolidated doc: %s', consolidatedDocId);
+  }
+
+  const lastDate = new Date(lastISO);
+
+  // Find threads with the label
+  const query = `label:${CONSOLIDATE_LABEL}`;
+  const threads = GmailApp.search(query, 0, MAX_MESSAGES_PER_RUN);
+
+  // Collect messages newer than lastDate
+  let newMessages = [];
+  for (let i = 0; i < threads.length; i++) {
+    const t = threads[i];
+    const msgs = t.getMessages();
+    for (let j = 0; j < msgs.length; j++) {
+      const m = msgs[j];
+      const d = m.getDate();
+      if (d > lastDate) {
+        newMessages.push({date: d, message: m});
+      }
+    }
+  }
+
+  if (newMessages.length === 0) {
+    Logger.log('No new messages to process.');
+    return;
+  }
+
+  // Sort newest -> oldest
+  newMessages.sort((a,b) => b.date - a.date);
+  Logger.log('Found %s new messages.', newMessages.length);
+
+  let newestSeen = lastDate;
+
+  // Process each new message (newest-first)
+  newMessages.forEach(item => {
+    const msg = item.message;
+    try {
+      if (OUTPUT_MODE === 'doc_plain') {
+        prependMessageToDocPlain(msg, consolidatedDocId);
+      } else if (OUTPUT_MODE === 'doc_html') {
+        prependMessageHtmlToDoc(msg, consolidatedDocId);
+      } else {
+        throw new Error('Unknown OUTPUT_MODE: ' + OUTPUT_MODE);
+      }
+      if (item.date > newestSeen) newestSeen = item.date;
+      Logger.log('Processed message: %s (date=%s)', msg.getSubject(), msg.getDate());
+    } catch (e) {
+      Logger.log('Error processing message (subject=%s): %s', msg.getSubject(), e.toString());
+    }
+  });
+
+  // Update state
+  props.setProperty(PROP_LAST_ISO, newestSeen.toISOString());
+  Logger.log('State updated. new lastISO=%s', newestSeen.toISOString());
+}
+
diff --git a/docs_utils.gs b/docs_utils.gs
new file mode 100644
index 0000000..1b3d5cc
--- /dev/null
+++ b/docs_utils.gs
@@ -0,0 +1,195 @@
+/**
+ * docs_utils.gs
+ * Helpers for Google-Doc output mode.
+ *
+ * Contains:
+ *  - prependMessageToDocPlain(msg, consolidatedDocId)
+ *  - convertHtmlToDoc(htmlString, title)  (requires Advanced Drive service 'Drive')
+ *  - prependMessageHtmlToDoc(msg, consolidatedDocId)
+ *  - escapeHtml(s)
+ *  - copyElementToBody(child, destBody)   (basic element copier)
+ */
+
+/**
+ * Prepend a message into consolidated doc using plain text (very reliable).
+ * Newest messages are inserted at the top.
+ */
+function prependMessageToDocPlain(msg, consolidatedDocId) {
+  const mainDoc  = DocumentApp.openById(consolidatedDocId);
+  const mainBody = mainDoc.getBody();
+
+  // Build temporary doc for the message content
+  const tmpDoc  = DocumentApp.create('gtd_tmp_msg_' + new Date().getTime());
+  const tmpBody = tmpDoc.getBody();
+
+  tmpBody.appendParagraph('--- EMAIL START ---').setHeading(DocumentApp.ParagraphHeading.HEADING6);
+  tmpBody.appendParagraph('Subject: ' + (msg.getSubject() || '(no subject)'));
+  tmpBody.appendParagraph('From: ' + (msg.getFrom() || ''));
+  tmpBody.appendParagraph('To: ' + (msg.getTo() || ''));
+  tmpBody.appendParagraph('Date: ' + msg.getDate().toString());
+  tmpBody.appendParagraph('');
+
+  const plain = (msg.getPlainBody && msg.getPlainBody()) ? msg.getPlainBody()
+               : (msg.getBody && msg.getBody()) ? msg.getBody()
+               : '(no body)';
+  plain.split(/\r?\n/).forEach(line => {
+    tmpBody.appendParagraph(line);
+  });
+
+  tmpBody.appendParagraph('--- EMAIL END ---');
+  tmpBody.appendPageBreak();
+
+  // Insert tmpDoc children into mainDoc at the top (insert in reverse so order is preserved)
+  const n = tmpBody.getNumChildren();
+  for (let i = n - 1; i >= 0; i--) {
+    const child = tmpBody.getChild(i).copy();
+    try {
+      if (child.getType && child.getType() === DocumentApp.ElementType.PARAGRAPH) {
+        mainBody.insertParagraph(0, child.asParagraph().getText());
+      } else if (child.getType && child.getType() === DocumentApp.ElementType.LIST_ITEM) {
+        mainBody.insertListItem(0, child.asListItem().getText());
+      } else if (child.getType && child.getType() === DocumentApp.ElementType.PAGE_BREAK) {
+        mainBody.insertPageBreak(0);
+      } else {
+        // fallback - plain text
+        mainBody.insertParagraph(0, child.getText ? child.getText() : '[unsupported element]');
+      }
+    } catch (err) {
+      mainBody.insertParagraph(0, '[insert failed: ' + err.toString() + ']');
+    }
+  }
+
+  // Remove temporary doc to avoid clutter
+  DriveApp.getFileById(tmpDoc.getId()).setTrashed(true);
+}
+
+/**
+ * Convert HTML string into a Google Doc using Drive API convert.
+ * Requires Advanced Drive Service enabled in the Apps Script editor (Services -> Drive API).
+ * Returns the new docId.
+ */
+function convertHtmlToDoc(htmlString, title) {
+  const blob = Utilities.newBlob(htmlString, 'text/html', title + '.html');
+  const resource = {
+    title: title,
+    mimeType: 'text/html'
+  };
+  // Drive.Files.insert converts the uploaded HTML into a Google Doc when convert=true
+  const file = Drive.Files.insert(resource, blob, {convert: true});
+  return file.id;
+}
+
+/**
+ * Prepend HTML message into consolidated doc.
+ * This converts message HTML->Doc via Drive.Files.insert convert=true,
+ * then copies the doc content into the consolidated doc.
+ *
+ * NOTE:
+ *  - This is a pragmatic approach; it won't automatically resolve inline 'cid:' images.
+ *  - For better fidelity, add image fetching & data-URI replacement before conversion.
+ */
+function prependMessageHtmlToDoc(msg, consolidatedDocId) {
+  const htmlHeader = `
+    <html><head><meta charset="utf-8"></head><body>
+    <div><strong>Subject:</strong> ${escapeHtml(msg.getSubject() || '')}</div>
+    <div><strong>From:</strong> ${escapeHtml(msg.getFrom() || '')}</div>
+    <div><strong>To:</strong> ${escapeHtml(msg.getTo() || '')}</div>
+    <div><strong>Date:</strong> ${escapeHtml(msg.getDate().toString())}</div>
+    <hr/>`;
+
+  // Prefer the HTML body when present
+  const bodyHtml = (msg.getBody && msg.getBody()) ? msg.getBody()
+                  : escapeHtml((msg.getPlainBody && msg.getPlainBody()) ? msg.getPlainBody() : '(no body)');
+
+  const fullHtml = htmlHeader + bodyHtml + '</body></html>';
+
+  const tmpDocId = convertHtmlToDoc(fullHtml, 'gtd_tmp_html_' + new Date().getTime());
+
+  // Copy children from tmpDoc to consolidated doc at top
+  const tmpDoc  = DocumentApp.openById(tmpDocId);
+  const tmpBody = tmpDoc.getBody();
+  const mainDoc = DocumentApp.openById(consolidatedDocId);
+  const mainBody= mainDoc.getBody();
+
+  for (let i = tmpBody.getNumChildren() - 1; i >= 0; i--) {
+    const child = tmpBody.getChild(i).copy();
+    try {
+      if (child.getType && child.getType() === DocumentApp.ElementType.PARAGRAPH) {
+        mainBody.insertParagraph(0, child.asParagraph().getText());
+      } else if (child.getType && child.getType() === DocumentApp.ElementType.LIST_ITEM) {
+        mainBody.insertListItem(0, child.asListItem().getText());
+      } else if (child.getType && child.getType() === DocumentApp.ElementType.TABLE) {
+        // basic table flattening
+        const table = child.asTable();
+        for (let r = table.getNumRows() - 1; r >= 0; r--) {
+          const row = table.getRow(r);
+          let rowText = [];
+          for (let c = 0; c < row.getNumCells(); c++) {
+            rowText.push(row.getCell(c).getText());
+          }
+          mainBody.insertParagraph(0, rowText.join('\t'));
+        }
+      } else if (child.getType && child.getType() === DocumentApp.ElementType.PAGE_BREAK) {
+        mainBody.insertPageBreak(0);
+      } else if (child.getType && child.getType() === DocumentApp.ElementType.INLINE_IMAGE) {
+        const blob = child.asInlineImage().getBlob();
+        mainBody.insertImage(0, blob);
+      } else {
+        mainBody.insertParagraph(0, child.getText ? child.getText() : '[unsupported element]');
+      }
+    } catch (e) {
+      mainBody.insertParagraph(0, '[insert failed: ' + e.toString() + ']');
+    }
+  }
+
+  // Trash tmp doc
+  DriveApp.getFileById(tmpDocId).setTrashed(true);
+}
+
+/* Minimal HTML escape to avoid injecting tags into metadata fields */
+function escapeHtml(s) {
+  return String(s)
+    .replace(/&/g, '&amp;')
+    .replace(/</g, '&lt;')
+    .replace(/>/g, '&gt;');
+}
+
+/**
+ * copyElementToBody(child, destBody)
+ * A small element copier to support Paragraphs, ListItems, Tables, InlineImage, PageBreak.
+ * Not exhaustive but useful later when preserving element types becomes important.
+ */
+function copyElementToBody(child, destBody) {
+  const type = child.getType();
+  switch (type) {
+    case DocumentApp.ElementType.PARAGRAPH:
+      destBody.appendParagraph(child.asParagraph().getText());
+      break;
+    case DocumentApp.ElementType.LIST_ITEM:
+      destBody.appendListItem(child.asListItem().getText());
+      break;
+    case DocumentApp.ElementType.TABLE:
+      const table = child.asTable();
+      for (let r = 0; r < table.getNumRows(); r++) {
+        const cells = table.getRow(r).getNumCells();
+        let rowText = [];
+        for (let c = 0; c < cells; c++) {
+          rowText.push(table.getRow(r).getCell(c).getText());
+        }
+        destBody.appendParagraph(rowText.join('\t'));
+      }
+      break;
+    case DocumentApp.ElementType.INLINE_IMAGE:
+      try {
+        const blob = child.asInlineImage().getBlob();
+        destBody.appendImage(blob);
+      } catch (e) {
+        destBody.appendParagraph('[image error]');
+      }
+      break;
+    case DocumentApp.ElementType.PAGE_BREAK:
+      destBody.appendPageBreak();
+      break;
+    default:
+      try {
+        destBody.appendParagraph(child.getText ? child.getText() : child.asText().getText());
+      } catch (e) {
+        destBody.appendParagraph('[unsupported element]');
+      }
+  }
+}
+
diff --git a/docs/GOOGLE_DOCS_MODE.md b/docs/GOOGLE_DOCS_MODE.md
new file mode 100644
index 0000000..2f6b8a1
--- /dev/null
+++ b/docs/GOOGLE_DOCS_MODE.md
@@ -0,0 +1,73 @@
+# Google Docs Output Mode (gmail-to-docs)
+
+This fork adds a Google Docs output path that **prepends** new emails (newest-first) into a **single consolidated Google Doc**.
+
+## Quick Start
+
+1. In Gmail, create a label (e.g., `CONSOLIDATE_TO_DOC`) and apply it to the messages you want consolidated.
+2. Open the Apps Script project and ensure the manifest uses V8 runtime:
+   - `appsscript.json` includes `"runtimeVersion": "V8"`.
+3. Add the files `docs_mode.gs` and `docs_utils.gs` to your project.
+4. In `docs_mode.gs`, set:
+   - `CONSOLIDATE_LABEL` to your label (e.g., `CONSOLIDATE_TO_DOC`)
+   - `OUTPUT_MODE` to `'doc_plain'` (recommended first) or `'doc_html'` (requires Drive Advanced Service).
+5. Run `gtd_init()` once (optional) and then `processMessagesToDoc()` to authorize and process initial messages.
+6. Set a time-driven trigger to run `processMessagesToDoc()` on a schedule (e.g., every 10 minutes).
+
+State is stored in Script Properties:
+- `gtd_last_iso` — ISO datetime of the last processed message.
+- `gtd_consolidated_doc_id` — doc id of the consolidated Google Doc.
+
+## Modes
+
+- `doc_plain`: converts messages to plain text with simple metadata; very robust.
+- `doc_html`: attempts HTML → Google Doc conversion via Drive API. Turn on **Advanced Drive Service** in the Apps Script editor (Services → Drive API). Better formatting for some emails, but HTML/CSS fidelity varies, and inline `cid:` images may need custom handling.
+
+## Notes / Next Steps
+
+- For very long Docs (size limits), create monthly archives and rotate `gtd_consolidated_doc_id`.
+- Inline images and attachments are not fully handled yet in this first patch. Future work:
+  - Embed inline images by fetching attachments that match `Content-ID` and inserting them as images in the Doc.
+  - Save non-image attachments to a Drive folder and insert links in the consolidated Doc.
+  - Add a guard to skip re-processing already-added messages by tracking message IDs.
+
+## Troubleshooting
+
+- If you see “Service not found: Drive”, enable **Advanced Drive Service** (Services → Add a service → Drive API).
+- If nothing is added to the doc, confirm your label name matches `CONSOLIDATE_LABEL` and there are labeled messages **newer than** `gtd_last_iso`. You can reset by setting `gtd_last_iso` to `1970-01-01T00:00:00Z` in Script Properties.
+- Logs are in **Executions** in the Apps Script editor (or `Logger.log` output).
</file>

<file path="Examples.gs">
/*
 * The following are example functions which utilize the GmailUtils and
 * DriveUtils libraries to convert Gmail messages into PDF files.
 */


// Iterate through all starred messages with the label 'Expenses' (up to 5
// messages per call), convert each to a PDF, and save them to Google Drive,
// then unstar each message after archival.

function saveExpenses() {
  GmailUtils.processStarred('label:Expenses', 5, function(message) {

    // create a pdf of the message
    var pdf = GmailUtils.messageToPdf(message);

    // prefix the pdf filename with a date string
    pdf.setName(GmailUtils.formatDate(message, 'yyyyMMdd - ') + pdf.getName());

    // save the converted file to the 'Expenses' folder within Google Drive
    DriveUtils.getFolder('Expenses').createFile(pdf);

    // signal that we are done with this email and it will be marked as read
    return true;
  });
}


// Convert the 10 most recent unread messages in the "promotions" category
// into a single pdf, mark them as read, and email the digest to yourself.

function unreadPromotionsDigest() {
  var to = Session.getActiveUser().getEmail(),
      subject = 'Latest promotional emails',
      body = "here's your unread promotional emails:",
      messages = [];

  // limit this to 10 threads (may be more than 10 messages)
  GmailUtils.processUnread('category:promotions', 10, function(message) {
    messages.push(message);
    return true;
  });

  // convert the group of messages into a single pdf
  var pdf = GmailUtils.messageToPdf(messages, {filename: 'recent_promos.pdf'});

  // email the converted document
  GmailApp.sendEmail(to, subject, body, {attachments: [pdf]});
}
</file>

<file path="DriveUtils.gs">
/*
 * DriveUtils
 * ==========
 *
 * A collection of utilities for use with Google Drive and the DriveApp object.
 *
 * To utilize this library, select Resources > Libraries... and enter the following project key:
 * MUDdULBfiLdgEZ13bA9paOlVaKzeOjMwH
 */

/**
 * Get a folder or create it if it does not exist
 *
 * @method getFolder
 * @param {string} name
 * @return {Folder} object
 */
function getFolder(name) {
  var folders = DriveApp.getFoldersByName(name);
  return folders.hasNext() ? folders.next() : DriveApp.createFolder(name);
}
</file>

<file path="README.md">
Gmail To PDF
============

A helpful collection of Google Apps Script utilities which allow you to
painlessly transform Gmail messages into PDFs.

This handles all of the heavy-lifting needed to preserve all attachments,
inline-images, remote images, backgrounds, etc. Also included are a few helpful
methods for creating virtual queues within your Gmail labels, using either
unread status or starred status as a signifier.

![PDF Example](conversion.png)


## Getting Started

To get started, you can either open the [example project][2], create a copy, and
modify it to your liking, or you can create a new [Google Apps Script][1]
project and add [GmailUtils][3] and [DriveUtils][4] as libraries by going to
**_Resources_ > _Libraries..._** and entering the following project IDs:

* `MsE3tErxE9G0z6EMfGmUGqVVaKzeOjMwH`
* `MUDdULBfiLdgEZ13bA9paOlVaKzeOjMwH`

Alternatively, you can import GmailUtils.gs or DriveUtils.gs into your own
project and access the library directly with no name spacing.

[1]: https://script.google.com/ (Google Apps Script)
[2]: https://script.google.com/d/1qdkT9ShXl4VWO9XvKefcxmH_oRJe31MPDyIDsOKyGidKr-GHBpULLtvx/edit?usp=sharing (Example Project)
[3]: https://script.google.com/d/1V9HLEXHv4-7muXGhMS0XC-Lon5WX1CQhtfmjmaVp7WSHoeswwfkq1-90/edit?usp=sharing (GmailUtils Project)
[4]: https://script.google.com/d/1eCTCV107E322s7R_04tLwIg2Q059xEoUytFHBZS5ccbw4TS_DBBOADGo/edit?usp=sharing (DriveUtils Project)


## Example Usage

Iterate through all starred messages with the label 'Expenses' (up to 5 messages
per call), convert each to a PDF, and save them to Google Drive, then unstar
each message after archival.

```javascript
function saveExpenses() {
  GmailUtils.processStarred('label:Expenses', 5, function(message) {

    // create a pdf of the message
    var pdf = GmailUtils.messageToPdf(message);

    // prefix the pdf filename with a date string
    pdf.setName(GmailUtils.formatDate(message, 'yyyyMMdd - ') + pdf.getName());

    // save the converted file to the 'Expenses' folder within Google Drive
    DriveUtils.getFolder('Expenses').createFile(pdf);

    // signal that we are done with this email and it will be marked as read
    return true;
  });
}
```

Convert the 10 most recent unread messages in the "promotions" category into a
single pdf, mark them as read, and email the digest to yourself.

```javascript
function unreadPromotionsDigest() {
  var to = Session.getActiveUser().getEmail(),
      subject = 'Latest promotional emails',
      body = "here's your unread promotional emails:",
      messages = [];

  // limit this to 10 threads (may be more than 10 messages)
  GmailUtils.processUnread('category:promotions', 10, function(message) {
    messages.push(message);
    return true;
  });

  // convert the group of messages into a single pdf
  var pdf = GmailUtils.messageToPdf(messages, {filename: 'recent_promos.pdf'});

  // email the converted document
  GmailApp.sendEmail(to, subject, body, {attachments: [pdf]});
}
```


LICENSE
=======

The MIT License (MIT)

Copyright (c) 2015 PixelCog Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="GmailUtils.gs">
/*
 * GmailUtils
 * ==========
 *
 * A collection of utilities for use with Google Apps Email and the GmailApp object, primarily
 * focused on archiving messages as PDFs.
 *
 * To utilize this library, select Resources > Libraries... and enter the following project key:
 * MsE3tErxE9G0z6EMfGmUGqVVaKzeOjMwH
 */

/**
 * Iterate through all messages matching the given query.
 *
 * @method eachMessage
 * @param {string} query (optional, default 'in:inbox')
 * @param {number} limit (optional, default 10)
 * @param {function} callback
 */
function eachMessage(query, limit, callback) {
  if (typeof query == 'function') {
    callback = query;
    query = null;
    limit = null;
  }
  if (typeof limit == 'function') {
    callback = limit;
    limit = null;
  }
  if (typeof callback != 'function') {
    throw "No callback provided";
  }
  limit = parseInt(limit) || 10;
  query = query || 'in:inbox';

  var threads = GmailApp.search(query, 0, limit);
  for (var t=0; t < threads.length; t++) {
    var messages = threads[t].getMessages();
    for (var m=0; m < messages.length; m++) {
      callback(messages[m]);
    }
  }
}

/**
 * Iterate through all starred messages which match the given query. When the callback returns a
 * positive value, the message is unstarred.
 *
 * @method processStarred
 * @param {string} query (optional, default 'is:starred')
 * @param {number} limit (optional, default 10)
 * @param {function} callback
 */
function processStarred(query, limit, callback) {
  if (typeof query == 'function') {
    callback = query;
    query = null;
    limit = null;
  }
  if (typeof limit == 'function') {
    callback = limit;
    limit = null;
  }
  if (typeof callback != 'function') {
    throw "No callback provided";
  }
  query = (query ? query + ' AND ' : '') + 'is:starred';

  eachMessage(query, limit, function(message) {
    message.isStarred() && !message.isInTrash() && callback(message) && message.unstar();
  });
}

/**
 * Iterate through all unread messages which match the given query. When the callback returns a
 * positive value, the message is marked as read.
 *
 * @method processUnread
 * @param {string} query (optional, default 'is:unread')
 * @param {number} limit (optional, default 10)
 * @param {function} callback
 */
function processUnread(query, limit, callback) {
  if (typeof query == 'function') {
    callback = query;
    query = null;
    limit = null;
  }
  if (typeof limit == 'function') {
    callback = limit;
    limit = null;
  }
  if (typeof callback != 'function') {
    throw "No callback provided";
  }
  query = (query ? query + ' AND ' : '') + 'is:unread';

  eachMessage(query, limit, function(message) {
    message.isUnread() && !message.isInTrash() && callback(message) && message.markRead();
  });
}

/**
 * Wrapper for Utilities.formatDate() which provides sensible defaults
 *
 * @method formatDate
 * @param {string} message
 * @param {string} format
 * @param {string} timezone
 * @return {string} Formatted date
 */
function formatDate(message, format, timezone) {
  timezone = timezone || localTimezone_();
  format = format || "MMMMM dd, yyyy 'at' h:mm a '" + timezone + "'";
  return Utilities.formatDate(message.getDate(), timezone, format)
}

/**
 * Determine whether a message has a pdf attached to it and if so, return it
 *
 * @method messageGetPdfAttachment
 * @param {GmailMessage} message GmailMessage object
 * @return {Blob|boolean} Blob on success, else false
 */
function messageGetPdfAttachment(message) {
  var attachments = message.getAttachments();
  for (var i=0; i < attachments.length; i++) {
    if (attachments[i].getContentType() == 'application/octet-stream') {
      attachments[i].setContentTypeFromExtension();
    }
    if (attachments[i].getContentType() == 'application/pdf') {
      return attachments[i].copyBlob();
    }
  }
  return false;
}

/**
 * Convert a Gmail message or thread to a PDF and return it as a blob
 *
 * @method messageToPdf
 * @param {GmailMessage|GmailThread} messages GmailMessage or GmailThread object (or an array of such objects)
 * @return {Blob}
 */
function messageToPdf(messages, opts) {
  return messageToHtml(messages, opts).getAs('application/pdf');
}

/**
 * Convert a Gmail message or thread to a HTML and return it as a blob
 *
 * @method messageToHtml
 * @param {GmailMessage|GmailThread} messages GmailMessage or GmailThread object (or an array of such objects)
 * @param {Object} options
 * @return {Blob}
 */
function messageToHtml(messages, opts) {
  opts = opts || {};
  defaults_(opts, {
    includeHeader: true,
    includeAttachments: true,
    embedAttachments: true,
    embedRemoteImages: true,
    embedInlineImages: true,
    embedAvatar: true,
    width: 700,
    filename: null
  });

  if (!(messages instanceof Array)) {
    messages = isa_(messages, 'GmailThread') ? messages.getMessages() : [messages];
  }
  if (!messages.every(function(obj){ return isa_(obj, 'GmailMessage'); })) {
    throw "Argument must be of type GmailMessage or GmailThread.";
  }
  var name = opts.filename || sanitizeFilename_(messages[messages.length-1].getSubject()) + '.html';
  var html = '<html>\n' +
             '<style type="text/css">\n' +
             'body{padding:0 10px;min-width:' + opts.width + 'px;-webkit-print-color-adjust: exact;}' +
             'body>dl.email-meta{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;padding:0 0 10px;margin:0 0 5px;border-bottom:1px solid #ddd;page-break-before:always}' +
             'body>dl.email-meta:first-child{page-break-before:auto}' +
             'body>dl.email-meta dt{color:#808080;float:left;width:60px;clear:left;text-align:right;overflow:hidden;text-overf‌low:ellipsis;white-space:nowrap;font-style:normal;font-weight:700;line-height:1.4}' +
             'body>dl.email-meta dd{margin-left:70px;line-height:1.4}' +
             'body>dl.email-meta dd a{color:#808080;font-size:0.85em;text-decoration:none;font-weight:normal}' +
             'body>dl.email-meta dd.avatar{float:right}' +
             'body>dl.email-meta dd.avatar img{max-height:72px;max-width:72px;border-radius:36px}' +
             'body>dl.email-meta dd.strong{font-weight:bold}' +
             'body>div.email-attachments{font-size:0.85em;color:#999}' +
             '</style>\n' +
             '<body>\n';

  for (var m=0; m < messages.length; m++) {
    var message = messages[m],
        subject = message.getSubject(),
        avatar = null,
        date = formatDate(message),
        from = formatEmails_(message.getFrom()),
        to   = formatEmails_(message.getTo()),
        cc   = formatEmails_(message.getCc()),
        bcc  = formatEmails_(message.getBcc()),
        body = message.getBody();

    if (opts.includeHeader) {
      if (opts.embedAvatar && (avatar = emailGetAvatar(from))) {
        avatar = '<dd class="avatar"><img src="' + renderDataUri_(avatar) + '" /></dd> ';
      } else {
        avatar = '';
      }
      html += '<dl class="email-meta">\n' +
              '<dt>From:</dt>' + avatar + ' <dd class="strong">' + from + '</dd>\n' +
              '<dt>Subject:</dt> <dd>' + subject + '</dd>\n' +
              '<dt>Date:</dt> <dd>' + date + '</dd>\n' +
              '<dt>To:</dt> <dd>' + to + '</dd>\n';
    }
    // Appending cc and bcc if they exist
    if(isRealValue(cc)){
          html += '<dt>cc:</dt> <dd>' + cc + '</dd>\n';
    }
    if(isRealValue(bcc)){
          html += '<dt>bcc:</dt> <dd>' + bcc + '</dd>\n';
    }
    html += '</dl>\n';
    if (opts.embedRemoteImages) {
      body = embedHtmlImages_(body);
    }
    if (opts.embedInlineImages) {
      body = embedInlineImages_(body, message.getRawContent());
    }
    if (opts.includeAttachments) {
      var attachments = message.getAttachments();
      if (attachments.length > 0) {
        body += '<br />\n<strong>Attachments:</strong>\n' +
                '<div class="email-attachments">\n';

        for (var a=0; a < attachments.length; a++) {
          var filename = attachments[a].getName();
          var imageData;

          if (opts.embedAttachments && (imageData = renderDataUri_(attachments[a]))) {
            body += '<img src="' + imageData + '" alt="&lt;' + filename + '&gt;" /><br />\n';
          } else {
            body += '&lt;' + filename + '&gt;<br />\n';
          }
        }
        body += '</div>\n';
      }
    }
    html += body;
  }
  html += '</body>\n</html>';

  return Utilities.newBlob(html, 'text/html', name);
}

/**
 * Returns the name associated with an email string, or the domain name of the email.
 *
 * @method emailGetName
 * @param {string} email
 * @return {string} name or domain name
 */
function emailGetName(email) {
  return email.replace(/^<?(?:[^<\(]+@)?([^<\(,]+?|)(?:\s?[\(<>,].*|)$/i, '$1') || 'Unknown';
}

/**
 * Attempt to download an image representative of the email address provided. Using gravatar or
 * apple touch icons as appropriate.
 *
 * @method emailGetAvatar
 * @param {string} email
 * @return {Blob|boolean} Blob object or false
 */
function emailGetAvatar(email) {
  re = /[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/gi
  if (!(email = email.match(re)) || !(email = email[0].toLowerCase())) {
    return false;
  }
  var domain = email.split('@')[1];
  var avatar = fetchRemoteFile_('http://www.gravatar.com/avatar/' + md5_(email) + '?s=128&d=404');
  if (!avatar && ['gmail','hotmail','yahoo.'].every(function(s){ return domain.indexOf(s) == -1 })) {
    avatar = fetchRemoteFile_('http://' + domain + '/apple-touch-icon.png') ||
             fetchRemoteFile_('http://' + domain + '/apple-touch-icon-precomposed.png');
  }
  return avatar;
}

/**
 * Download and embed all images referenced within an html document as data uris
 *
 * @param {string} html
 * @return {string} Html with embedded images
 */
function embedHtmlImages_(html) {
  // process all img tags
  html = processImageTags(html);
  // process all style attributes
  html = processStyleAttributes(html);
  // process all style tags
  html = processStyleTags(html);
  return html;
}

/**
 * Download and embed all img tags
 *
 * @param {string} html
 * @return {string} Html with embedded images
 */
function processImageTags(html){
    return html.replace(/(<img[^>]+src=)(["'])((?:(?!\2)[^\\]|\\.)*)\2/gi, function(m, tag, q, src) {
        // Logger.log('Processing image src: ' + src);
        return tag + q + (renderDataUri_(src) || src) + q;
    });
}

/**
 * Download and embed all HTML Style Attributes
 *
 * @param {string} html
 * @return {string} Html with embedded style attributes
 */
function processStyleAttributes(html){
    return html.replace(/(<[^>]+style=)(["'])((?:(?!\2)[^\\]|\\.)*)\2/gi, function(m, tag, q, style) {
        style = style.replace(/url\((\\?["']?)([^\)]*)\1\)/gi, function(m, q, url) {
            return 'url(' + q + (renderDataUri_(url) || url) + q + ')';
        });
        return tag + q + style + q;
    });
}

/**
 * Download and embed all HTML Style Tags
 *
 * @param {string} html
 * @return {string} Html with embedded style tags
 */
function processStyleTags(html){
    return html.replace(/(<style[^>]*>)(.*?)(?:<\/style>)/gi, function(m, tag, style, end) {
    style = style.replace(/url\((["']?)([^\)]*)\1\)/gi, function(m, q, url) {
      return 'url(' + q + (renderDataUri_(url) || url) + q + ')';
    });
    return tag + style + end;
  });
}

/**
 * Extract and embed all inline images (experimental)
 *
 * @param {string} html Message body
 * @param {string} raw Unformatted message contents
 * @return {string} Html with embedded images
 */
function embedInlineImages_(html, raw) {
  var images = [];

  // locate all inline content ids
  raw.replace(/<img[^>]+src=(?:3D)?(["'])cid:((?:(?!\1)[^\\]|\\.)*)\1/gi, function(m, q, cid) {
    images.push(cid);
    return m;
  });

  // extract all inline images
  images = images.map(function(cid) {
    var cidIndex = raw.search(new RegExp("Content-ID ?:.*?" + cid, 'i'));
    if (cidIndex === -1) return null;

    var prevBoundaryIndex = raw.lastIndexOf("\r\n--", cidIndex);
    var nextBoundaryIndex = raw.indexOf("\r\n--", prevBoundaryIndex+1);
    var part = raw.substring(prevBoundaryIndex, nextBoundaryIndex);

    var encodingLine = part.match(/Content-Transfer-Encoding:.*?\r\n/i)[0];
    var encoding = encodingLine.split(":")[1].trim();
    if (encoding != "base64") return null;

    var contentTypeLine = part.match(/Content-Type:.*?\r\n/i)[0];
    var contentType = contentTypeLine.split(":")[1].split(";")[0].trim();

    var startOfBlob = part.indexOf("\r\n\r\n");
    var blobText = part.substring(startOfBlob).replace("\r\n","");

    return Utilities.newBlob(Utilities.base64Decode(blobText), contentType, cid);
  }).filter(function(i){return i});

  // process all img tags which reference "attachments"
  return processImgAttachments(html);
}

/**
 * Download and embed all HTML Inline Image Attachments
 *
 * @param {string} html
 * @return {string} Html with inline image attachments
 */
function processImgAttachments(html){
    return html.replace(/(<img[^>]+src=)(["'])(\?view=att(?:(?!\2)[^\\]|\\.)*)\2/gi, function(m, tag, q, src) {
        return tag + q + (renderDataUri_(images.shift()) || src) + q;
   });
}

/**
 * Convert an image into a base64-encoded data uri.
 *
 * @param {Blob|string} Blob object containing an image file or a remote url string
 * @return {string} Data uri
 */
function renderDataUri_(image) {
  if (typeof image == 'string' && !(isValidUrl_(image) && (image = fetchRemoteFile_(image)))) {
    return null;
  }
  if (isa_(image, 'Blob') || isa_(image, 'GmailAttachment')) {
    if (image.getContentType() != null) {
      var type = image.getContentType().toLowerCase();
      var data = Utilities.base64Encode(image.getBytes());
      if (type.indexOf('image') == 0) {
        return 'data:' + type + ';base64,' + data;
      }
    } 
  }
  return null;
}

/**
 * Fetch a remote file and return as a Blob object on success
 *
 * @param {string} url
 * @return {Blob}
 */
function fetchRemoteFile_(url) {
  try {
    var response = UrlFetchApp.fetch(url, {'muteHttpExceptions': true});
    return response.getResponseCode() == 200 ? response.getBlob() : null;
  } catch (e) {
    return null;
  }
}

/**
 * Validate a url string (taken from jQuery)
 *
 * @param {string} url
 * @return {boolean}
 */
function isValidUrl_(url) {
  return /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(url);
}

/**
 * Sanitize a filename by filtering out characters not allowed in most filesystems
 *
 * @param {string} filename
 * @return {string}
 */
function sanitizeFilename_(filename) {
  return filename.replace(/[\/\?<>\\:\*\|":\x00-\x1f\x80-\x9f]/g, '');
}

/**
 * Turn emails of the form "<handle@domain.tld>" into 'mailto:' links.
 *
 * @param {string} emails
 * @return {string}
 */
function formatEmails_(emails) {
  var pattern = new RegExp(/<(((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)>/i);
  return emails.replace(pattern, function(match, handle) {
    return '<a href="mailto:' + handle + '">' + handle + '</a>';
  });
}

/**
 * Test class name for Google Apps Script objects. They have no constructors so we must test them
 * with toString.
 *
 * @param {Object} obj
 * @param {string} class
 * @return {boolean}
 */
function isa_(obj, class) {
  return typeof obj == 'object' && typeof obj.constructor == 'undefined' && obj.toString() == class;
}

/**
 * Assign default attributes to an object.
 *
 * @param {Object} options
 * @param {Object} defaults
 */
function defaults_(options, defaults) {
  for (attr in defaults) {
    if (!options.hasOwnProperty(attr)) {
      options[attr] = defaults[attr];
    }
  }
}

/**
 * Get our current timezone string (or GMT if it cannot be determined)
 *
 * @return {string}
 */
function localTimezone_() {
  var timezone = new Date().toTimeString().match(/\(([a-z0-9]+)\)/i);
  return timezone.length ? timezone[1] : 'GMT';
}

/**
* Check if value is not null or undefined
*
* @param {Object} obj
* @return {boolean} true if object is not null or undefined
*/
function isRealValue(obj) {
 return obj && obj !== 'null' && obj !== 'undefined';
}

/**
 * Create an MD5 hash of a string and return the reult as hexadecimal.
 *
 * @param {string} str
 * @return {string}
 */
function md5_(str) {
  return Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, str).reduce(function(str,chr) {
    chr = (chr < 0 ? chr + 256 : chr).toString(16);
    return str + (chr.length==1?'0':'') + chr;
  },'');
}
</file>

</files>
